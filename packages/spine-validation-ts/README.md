# @spine-event-engine/validation-ts

TypeScript validation library for Protobuf messages with [Spine Validation](https://github.com/SpineEventEngine/validation/) options.

## Features

- ✅ Runtime validation of Protobuf messages against Spine validation constraints
- ✅ Support for all major Spine validation options
- ✅ Custom error messages with placeholder substitution
- ✅ Type-safe validation with full TypeScript support
- ✅ Works with [@bufbuild/protobuf](https://github.com/bufbuild/protobuf-es) (Protobuf-ES v2)
- ✅ Comprehensive test coverage (200+ tests)

## Prerequisites

**Important:** This library is specifically designed for TypeScript code 
generated by [Buf](https://buf.build/) using the Protobuf-ES code generator.

This library requires:
- **[Buf](https://buf.build/)** for Protobuf code generation
- **`@bufbuild/protobuf`** v2.10.2 or later for TypeScript/JavaScript runtime
- TypeScript code generated using `@bufbuild/protoc-gen-es`

**This library will NOT work with:**
- Code generated by `protoc` with other plugins (e.g., `ts-proto`, `protobuf.js`)
- Hand-written Protobuf TypeScript bindings
- Other Protobuf code generators

The package includes:
- Spine validation Proto definitions (`spine/options.proto`)
- TypeScript validation implementation
- Pre-configured TypeScript build

## Installation

```bash
npm install @spine-event-engine/validation-ts @bufbuild/protobuf
```

### Setup Code Generation

Ensure your project uses [Buf](https://buf.build/) with the Protobuf-ES plugin.

**buf.gen.yaml:**

```yaml
version: v2
plugins:
  - remote: buf.build/protocolbuffers/es:v2.2.3
    out: src/generated
```

Generate TypeScript code from the Proto files:

```bash
buf generate
```

## Quick Start

```typescript
import { create } from '@bufbuild/protobuf';
import { validate, Violations } from '@spine-event-engine/validation-ts';
import { UserSchema } from './generated/user_pb';

// Create a message with validation constraints.
const user = create(UserSchema, {
    name: '',  // This field is marked as `(required) = true`.
    email: ''  // This field is also required.
});

// Validate the message.
const violations = validate(UserSchema, user);

if (violations.length > 0) {
    // Use Violations utility object to access violation details.
    violations.forEach(violation => {
        const fieldPath = Violations.failurePath(violation);
        const message = Violations.formatMessage(violation);

        console.error(`${violation.typeName}.${fieldPath}: ${message}`);
    });
}
```

## API Reference

### `validate(schema, message)`

Validates a Protobuf message against its Spine validation constraints.

**Parameters:**
- `schema`: the message schema (e.g., `UserSchema`)
- `message`: the message instance to validate

**Returns:** array of `ConstraintViolation` objects (empty if valid)

Each `ConstraintViolation` contains:
- `typeName`: the message type that failed validation,
- `fieldPath`: the path to the field that violated the constraint,
- `message`: the error message with placeholders replaced,
- `param`: additional parameters related to the violation,
- `violation`: nested violations for complex constraints.

### `Violations` Utility

The `Violations` provides convenient methods for working with constraint violations.

#### `Violations.formatMessage(violation)`

Returns the formatted error message from a violation with all placeholders replaced by actual values.

**Parameters:**
- `violation`: the `ConstraintViolation` object

**Returns:** formatted error message string

**Example:**
```typescript
const message = Violations.formatMessage(violation);
// Returns: "Email must be valid. Provided: `invalid@`."
```

#### `Violations.failurePath(violation)`

Returns the field path as a dot-separated string.

**Parameters:**
- `violation`: the `ConstraintViolation` object

**Returns:** field path string (e.g., `"user.email"`)

**Example:**
```typescript
const fieldPath = Violations.failurePath(violation);
// Returns: "user.email"
```

### `formatViolations(violations)`

Formats an array of violations into a human-readable numbered list string.

Mostly usable for debugging.

**Parameters:**
- `violations`: array of `ConstraintViolation` objects

**Returns:** formatted string with one violation per line

**Example:**
```typescript
const violations = validate(UserSchema, user);
console.log(formatViolations(violations));
// Output:
// 1. example.User.name: A value must be set.
// 2. example.User.email: Email must be valid. Provided: `invalid@`.
```

**Note:** For production use, consider using `Violations.formatMessage()` and `Violations.failurePath()` 
to build custom error displays tailored to your application.

## Supported Validation Options

### Field-level options

- ✅ **`(required)`** - Ensures field has a non-default value
- ✅ **`(if_missing)`** - Custom error message for required fields
- ✅ **`(pattern)`** - Regex validation for string fields
- ✅ **`(min)` / `(max)`** - Numeric range validation with inclusive/exclusive bounds
- ✅ **`(range)`** - Bounded numeric ranges using bracket notation `[min..max]`, with custom error messages
- ✅ **`(distinct)`** - Ensures unique elements in repeated fields and map values
- ✅ **`(validate)`** - Enables recursive validation of nested messages
- ✅ **`(goes)`** - Field dependency validation (field can only be set if another field is set)

### Message-level options

- ✅ **`(require)`** - Requires specific field combinations using boolean logic

### Oneof-level options

- ✅ **`(choice)`** - Requires that a `oneof` group has at least one field set

### Not Supported

- ❌ **`(set_once)`** - Requires state tracking across validations (not feasible in TypeScript runtime)
- ❌ **`(if_set_again)`** - Companion to `(set_once)`
- ❌ **`(required_field)`** - Deprecated, replaced by `(require)`
- ❌ **`(is_required)`** - Deprecated, replaced by `(choice)`

## Example

```protobuf
syntax = "proto3";

import "spine/options.proto";

message User {
    option (require).fields = "id | email";

    int32 id = 1 [
        (set_once) = true,
        (min).value = "1"
    ];

    string name = 2 [
        (required) = true,
        (pattern).regex = "^[A-Za-z][A-Za-z0-9 ]{1,49}$",
        (pattern).error_msg = "Name must start with a letter and be 2-50 characters."
    ];

    string email = 3 [
        (required) = true,
        (pattern).regex = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$",
        (pattern).error_msg = "Email must be valid."
    ];

    int32 age = 4 [
        (range).value = "[13..120]"
    ];

    repeated string tags = 5 [
        (distinct) = true
    ];

    map<string, string> preferences = 6 [
        (distinct) = true  // Values must be unique.
    ];
}

message Address {
    string street = 1 [(required) = true];
    string city = 2 [(required) = true];
    string zip_code = 3 [
        (pattern).regex = "^[0-9]{5}$"
    ];
}

message UserProfile {
    User user = 1 [
        (required) = true,
        (validate) = true
    ];

    Address address = 2 [
        (validate) = true
    ];
}
```

## Validation Behavior

### Proto3 field semantics

In `proto3`, fields have default values:
- Numeric fields default to `0`
- String fields default to `""`
- Bool fields default to `false`
- Message fields default to `undefined`

The `(required)` validator considers a field "set" when:
- String fields are non-empty
- Numeric fields are non-zero
- Bool fields are `true` or `false` (both count as set)
- Message fields are not `undefined`
- Repeated fields have at least one element

### Nested validation

Use `(validate) = true` on message fields to recursively validate nested messages:

```protobuf
message Order {
    Product product = 1 [
        (required) = true,
        (validate) = true  // Validates Product's constraints too.
    ];
}
```

### Field dependencies

Use `(goes)` to enforce field dependencies:

```protobuf
message ShippingDetails {
    string tracking_number = 1 [
        (goes).with = "carrier",
        (goes).error_msg = "Tracking number requires carrier to be set."
    ];
    string carrier = 2 [(goes).with = "tracking_number"];
}
```

### Required field combinations

Use `(require)` for complex field requirements:

```protobuf
message ContactInfo {
    option (require).fields = "(phone & country_code) | email";

    string phone = 1;
    string country_code = 2;
    string email = 3;
}
```

### `Oneof` constraints

Use `(choice)` to require that a `oneof` group has a field set:

```protobuf
message PaymentMethod {
    oneof method {
        option (choice).required = true;
        option (choice).error_msg = "Payment method is required.";

        CreditCard credit_card = 1;
        BankAccount bank_account = 2;
        PayPal paypal = 3;
    }
}
```

## Testing

The package includes comprehensive test coverage with 200+ tests across 11 test suites:

- `basic-validation.test.ts` - Basic validation and formatting
- `required.test.ts` - `(required)` and `(if_missing)` options
- `pattern.test.ts` - `(pattern)` regex validation
- `required-field.test.ts` - `(require)` message-level option
- `min-max.test.ts` - `(min)` and `(max)` numeric validation
- `range.test.ts` - `(range)` bracket notation
- `distinct.test.ts` - `(distinct)` uniqueness validation
- `validate.test.ts` - `(validate)` nested validation
- `goes.test.ts` - `(goes)` field dependency validation
- `choice.test.ts` - `(choice)` `oneof` validation
- `integration.test.ts` - Complex multi-option scenarios

Run tests with:

```bash
npm test
```

## Development Notes

### Generated Code Patching

The package uses a post-generation script ([scripts/patch-generated.js](scripts/patch-generated.js)) to handle 
JavaScript reserved word conflicts in generated Protobuf code.

**Issue:**

The Spine `(require)` option generates an export named `require` in the TypeScript output:

```typescript
export const require: GenExtension<MessageOptions, RequireOption>
```

However, `require` is a reserved identifier in Node.js/CommonJS, which can cause issues with module systems and tooling.

**Solution:**

After running `buf generate`, the patch script automatically renames the export to `requireFields`:

```typescript
export const requireFields: GenExtension<MessageOptions, RequireOption>
```

This happens automatically as part of the build process:

```json
{
  "scripts": {
    "generate": "buf generate && node scripts/patch-generated.js"
  }
}
```

The script patches both the main generated files and test generated files, ensuring consistency across the codebase. 
This approach allows us to use the standard `(require)` option name in proto files while avoiding conflicts in the generated TypeScript code.

## License

Apache License 2.0

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.
